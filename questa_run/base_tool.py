import argparse
import os
import sys
import errno
from shlex import quote 
from subprocess import check_output,CalledProcessError,DEVNULL
from pathlib import Path
from abc import ABC,abstractmethod
from logger import Logger
from typing import Union,Optional
from abspath_tool import AbsPathTool
from string_util import StringUtil
from argsparser import Extend, ArgParser
    
class BaseTool(ABC, AbsPathTool, StringUtil, ArgParser):
    path_dict = {} # useful path
    opts_dict = {}
    _filelistdir = [] 
    _git_root = '' # store the git repo root
    _tool_root = '' # store the current run "tool" root
    _tool_dirs = [] # store all the available "tool" directory in a git repo
    _vlog = ''
    _vopt = ''
    _qverify = ''
    _comppath = ''
    
    def __init__(self,logger):
        AbsPathTool.__init__(self)
        StringUtil.__init__(self)
        ArgParser.__init__(self)
        self.parser = argparse.ArgumentParser(description="Tool Base Class",add_help=False,usage=argparse.SUPPRESS)
        self._workdir = os.getenv("QSTRUN_WORK","workdir")
        self.add_shared_args()
        self.subparsers = None # Placeholder
        self._user = os.getenv('USER') # get $USER env
        self._current_dir = Path.cwd().resolve() # get current directory  
        self._git_root = self._get_git_root() # get git root (if any)
        self._questa_run_dir = os.getenv("QSTRUN_HOME",Path(__file__).parent.resolve())
        
        self.path_dict.update({ 'current_dir' : str(self._current_dir).replace(self._user,r"${USER}"),
                                'questa_run_dir' : str(self._questa_run_dir),
                                'user' : self._user,
                                'git_root': self._format_path_with_env(path=self._git_root)}
                                )
        self._comppath = os.getenv("CompPath",self.path_dict['git_root']).replace(self._user,r"${USER}")
        self.logger = logger

    def add_shared_args(self):
        # TODO use this in the future for single source of truth
        self.add_args(parser=self.parser,args=self._get_shared_args())
        self.add_args(parser=self.parser,args=self._get_gui_args())
        self.add_args(parser=self.parser,args=self._get_flag_args())
        '''self.parser.add_argument('-t', '--top', help='Top module', default=None)
        self.parser.add_argument('-g', '--gui', help='enable gui mode', action='store_true')
        self.parser.add_argument('-cp', '--comppath', help='Component path used in .f files generated by febuild',type=str, default='')
        self.parser.add_argument('-l', '--lib', help='Library', default="oc_libVlog")
        self.parser.add_argument('-o', '--workdir', help='Workdir output directory', default=self._workdir)
        self.parser.add_argument('-f', '--filelist', help='filelist format supported by questa', action=Extend, nargs='*', default=[])
        self.parser.add_argument('-pf', '--pref_file', help='Tool Preferences or custom do commands pre analysis', action=Extend, nargs="*", default=[], type=str)
        self.parser.add_argument('-p', '--pref', help='Tool Preferences file or custom do file pre analysis', action=Extend, nargs='*', default=[],type=str)
        self.parser.add_argument('-do', '--dofile', help='do file', action=Extend, nargs="*", default=[],type=str)
        self.parser.add_argument('-w', '--waiver', help='add waiver files', action=Extend, nargs="*", default=[],type=str)
        self.parser.add_argument('-opt', '--tool_opts', help='Tool options file path', action=Extend, nargs="*", default=[],type=str)
        self.parser.add_argument('-pre', '--prescript', help='custom prescript csh file', action=Extend, nargs="*", default=[],type=str)
        self.parser.add_argument('-post', '--postscript', help='custom postscript csh file', action=Extend, nargs="*", default=[],type=str)
        self.parser.add_argument('-i', '-I', '--interactive', help='show batch job in the terminal',action="store_true", default=False)
        self.parser.add_argument('-fb', '--febuild', help='when used by febuild',action="store_true",default=False)
        self.parser.add_argument('-db','--database_file',help='Database file for GUI', default='', type=str)
        self.parser.add_argument('-v','--verbose',help='Specify for log file Debugging',action="store_true",default=False)
        self.parser.add_argument('-se','--skip_exec',help='Skip the submission to bsub',action='store_true',default=False)
        self.parser.add_argument('-del','--delete',help='clean the work directory',action='store_true',default=False)
        self.parser.add_argument('-c','--clean',help='clean the work directory',action='store_true',default=False)'''
        
    @abstractmethod
    def add_subcommands(self):
        """Override this to add tool-specific subcommands."""
        pass

    def _format_path_with_env(self, path) -> str:    
        try:
            parts = []
            for part in path.parts:
                parts.append('${USER}' if part == self._user else part)
            return str(Path(*parts))
        except (TypeError, AttributeError) as e:
            # Handle potential Path initialization errors
            return str(self._current_dir)
    
    def _get_git_root(self) -> Path:
        """Safely get Git root directory with error handling.
        
        Returns:
            Path: Absolute path to Git root directory if in a Git repo, else None.
        """
        try:
            git_root = Path(
                check_output(
                    ["git", "rev-parse", "--show-toplevel"],
                    stderr=DEVNULL,
                    universal_newlines=True
                ).strip()
            ).resolve()
            self._in_git_repo = True
            return git_root
        except (CalledProcessError, FileNotFoundError):
            self._in_git_repo = False
            print("Not in Git Directory. Git Root set as Current Directory")         
            return self._current_dir  # Not in a Git repo or git not installed, returning current directory

    def find_tool_dir(self, tool_name: str) -> Path:
        """Find the most relevant tool directory in a Git repository.
        
        Args:
            tool_name: Name of the tool directory to find (e.g., 'lint')
            
        Returns:
            Path: The most relevant tool directory path
        """
        parts = []
        # If not in git repo
        if not self._in_git_repo:
            return self._current_dir # return current directory and stop finding
        
        # Initialize tool directories list
        if not hasattr(self, '_tool_dirs'):
            self._tool_dirs = []
        else:
            self._tool_dirs.clear()
        
        if not self._git_root:
            print("Warning: Not in a Git repository")
            return (Path.cwd() / tool_name).resolve()
        
        # Get current working directory
        cwd = Path.cwd().resolve()
        
        # First check if we're already in a matching directory
        if cwd.name == tool_name and cwd.is_dir():
            for part in Path(cwd).parts:
                parts.append('${USER}' if part == self._user else part)
                cwd = str(Path(*parts))
            print(f"Already in {tool_name} directory: {cwd}")

            return cwd
        
        try:
            # Calculate relative path from Git root
            try:
                rel_cwd = cwd.relative_to(self._git_root)
                print(f"Working in: {rel_cwd}")
            except ValueError:
                print("Warning: CWD is outside Git repository")
                rel_cwd = None
            
            # Find all matching tool directories
            for d in self._git_root.rglob(tool_name):
                try:
                    if d.is_dir():
                        abs_path = d.resolve()
                        # Skip if it's our current directory (already checked)
                        if abs_path != cwd:
                            self._tool_dirs.append(abs_path)
                except (PermissionError, FileNotFoundError):
                    continue
            
            if not self._tool_dirs:
                print(f"No '{tool_name}' directories found in repository")
                return (self._git_root / tool_name).resolve()
            
            # Find best matching directory
            best_match = None
            best_score = -1
            
            for tool_dir in self._tool_dirs:
                try:
                    rel_tool = tool_dir.relative_to(self._git_root).parent
                    
                    # Calculate path match score
                    match_count = 0
                    for cwd_part, tool_part in zip(
                        rel_cwd.parts if rel_cwd else (),
                        rel_tool.parts
                    ):
                        if cwd_part == tool_part:
                            match_count += 1
                        else:
                            break
                    
                    # Update best match
                    if match_count > best_score:
                        best_score = match_count
                        best_match = tool_dir
                except ValueError:
                    continue
            
            if best_match:
                print(f"Found {len(self._tool_dirs)} {tool_name} directories, selecting: {best_match}")
                return best_match
            else:
                print("No suitable directory found, using default location")
                return (self._git_root / tool_name).resolve()
                
        except Exception as e:
            print(f"Error finding {tool_name} directory: {str(e)}")
            return (Path.cwd() / tool_name).resolve()
        
    def parse_tool_opts(self,tool_opts:list)-> dict: 
        """This functions parses the tool options file given to be used in commands vlog, qverify, cdc run... and returns a dict file"""
        self.opts_dict = {}
        if tool_opts:  # Checks if the list is not empty
            for tool_opt in tool_opts: # check for each file specified in opts.tool_opts (if multiple)
                with open(tool_opt, 'r') as f:  # open the file 
                    for line in f: # read line by line
                        line = line.strip() # strip any leading/trailing whitespaces and newline character/carriage return
                        if not line or line.startswith('#'):  # Skip empty lines and comments
                            continue
                        if '=>' not in line:  # Skip lines without '=>'
                            continue
                        key, value = line.split('=>', 1)  # Split on first '=>' only
                        self.opts_dict[key.strip()] = value.strip()  # remove any whitespaces around the values (if any)
        return self.opts_dict

    def gen_abspath(self, opts, strict: bool =False):
        self.logger.disable_console()
        
        # if not running using FE Build mode
        if not opts.febuild:
            # get the absoluate path of the new work directory and remove the previous work directory
            opts.workdir = os.path.abspath(opts.workdir + f"/{opts.top}/{opts.subparser_name}/")
            if opts.clean:
                os.system(f'rm -rf {opts.workdir}/*')
            # remake that workdir
            os.makedirs(opts.workdir, exist_ok=True)
            # Start the logging file
            self.logger.start_logging(log_file=f'{opts.workdir}/questa_run.log')
            if opts.clean:
                self.logger.underline('Work Directory Settings')
                self.logger.info(f'rm -rf {opts.workdir}/*')  
                self.logger.info(f"Constructed work directory path with top module '{opts.top}' and tool '{opts.subparser_name}'")
        else:
            # get the absolute path of opts.workdir argument
            opts.workdir = os.path.abspath(opts.workdir)
            # ensure that workdir exist, else make it
            os.makedirs(opts.workdir, exist_ok=True)
            self.logger.start_logging(log_file=f'{opts.workdir}/questa_run.log')
            self.logger.debug("FE Build mode - using workdir as-is")
        
        self.logger.info(f"Work Directory is: {opts.workdir}")
        
        # Start path processing to ensure they are absolute paths
        self.logger.line()
        self.logger.header(message='Starting Path -> Absolute Path Section',symbol='=')
        self.logger.underline("Starting Common Arguments path processing...")
        
        # if filelist is specified
        if opts.filelist:
            # --- File/Directory Paths ---
            self.logger.debug(f"Processing filelist with initial path: {opts.filelist}")
            opts.filelist = self.abs_path_list(path_list=opts.filelist, var_name="filelist", strict=True, check_exists=True)
            for i, file in enumerate(opts.filelist):
                self.logger.info(f'File {i+1}/{len(opts.filelist)} in filelist: {file}')
            self._filelistdir = [os.path.dirname(f) for f in opts.filelist] if opts.filelist else []
            self.logger.debug(f"Derived filelist directories: {self._filelistdir}")
        
        if opts.febuild:
            self.logger.info("FE Build mode detected - processing comp path")
            opts.comppath = self.abs_path(opts.comppath)
            self.logger.info(f"CompPath resolved to: {opts.comppath}")
        
        self.logger.debug(f"Processing waivers with initial value: {opts.waiver}")
        opts.waiver = self.replace_comppath(
            self.abs_path_list(path_list=opts.waiver, var_name="waivers", strict=False, check_exists=True),
            opts.comppath
        )
        for i, waiver_file in enumerate(opts.waiver):
            self.logger.info(f"Waiver File {i+1}/{len(opts.waiver)}: {waiver_file}")
        
        # common tool arguments
        path_attrs = ["pref_file", "dofile", "tool_opts", "prescript", "postscript"]
        self.logger.info(f"Processing common path attributes: {', '.join(path_attrs)}")
        
        for attr in path_attrs:
            original_value = getattr(opts, attr)
            self.logger.debug(f"Processing {attr} with initial value: {original_value}")
            
            processed_value = self.abs_path_list(
                path_list=original_value,
                var_name=attr,
                strict=False,
                check_exists=True
            )
            setattr(opts, attr, processed_value)
            
            # Logging for each attribute
            if processed_value:
                if isinstance(processed_value, list):
                    self.logger.info(f"Found {len(processed_value)} {attr} file(s):")
                    for i, path in enumerate(processed_value):
                        self.logger.info(f"{attr}[{i}]: {path}")
                else:
                    self.logger.info(f"{attr} resolved to: {processed_value}")
            else:
                self.logger.debug(f"No {attr} paths found or processed")
        
        self.logger.info("Path processing completed successfully")
        self.logger.line()
        
    def replace_comppath(self,flist,comppath):
        files=[]
        for file in flist:
            if file.endswith('.f'):
                with open(file) as f:
                    for line in f.readlines():
                        files.append(line.replace("$(CompPath)",comppath).strip())
            else:
                files.append(file)
        return files

    def _process_line(self, line, base_dir,line_num):
        """Process a single line from the filelist with proper path handling and existence checking.
        
        Args:
            line: Input line from filelist
            base_dir: Base directory for resolving relative paths
            
        Returns:
            Processed line with proper paths or None if path doesn't exist
        """
        self.logger.debug(f"Processing line: '{line}' with base_dir: '{base_dir}'")
        
        # Normalize whitespace and line endings
        original_line = line
        line = line.replace("\t", "    ").strip('\r\n').strip()
        if original_line != line:
            self.logger.debug(f"Normalized line from '{original_line}' to '{line}'")
        
        # Skip empty lines
        if not line:
            self.logger.debug("Skipping empty line")
            return ''
        
        # Preserve comments
        if line.startswith('#'):
            self.logger.debug(f"Preserving comment line: '{line}'")
            return line
        
        # Handle special directives and absolute paths
        special_prefixes = (
            '/', '$', '+define+',
            '+incdir+/', '+incdir+$'
        )
        if any(line.startswith(prefix) for prefix in special_prefixes):
            self.logger.debug(f"Line starts with special prefix - returning as-is: '{line}'")
            return line
        
        # Process +incdir+ with relative paths
        if line.startswith('+incdir+'):
            rel_path = line[len('+incdir+'):]
            self.logger.debug(f"Processing include directory directive with path: '{rel_path}'")
            
            if not rel_path.startswith(('/', '$')):
                abs_path = str((Path(base_dir) / rel_path).resolve())
                if not os.path.exists(abs_path):
                    self.logger.warning(f"Line {line_num}: Include directory does not exist: '{abs_path}'")
                    return ''
                result = f"+incdir+{abs_path}"
                self.logger.info(f"Converted relative include path '{rel_path}' to absolute path '{abs_path}'")
                return result
            
            self.logger.debug(f"Include path is already absolute or special - returning unchanged: '{line}'")
            return line
        
        # Process regular file paths
        if not line.startswith(('/', '$')):
            abs_path = str((Path(base_dir) / line).resolve())
            if not os.path.exists(abs_path):
                self.logger.warning(f"Line {line_num}: File path does not exist: '{abs_path}'")
                return ''
            self.logger.info(f"Converted relative file path '{line}' to absolute path '{abs_path}'")
            return abs_path
        
        self.logger.debug(f"Line appears to be absolute path or special - returning unchanged: '{line}'")
        
        return line
  
    def gen_filelist_abspaths(self, filelist, workdir: str, comppath: str = "",febuild = False) -> str:
        """
        Generate absolute paths from filelists and write to a consolidated file.
        
        Args:
            filelist: List of filelist paths to process
            workdir: Working directory path
            comppath: Component path to replace $(CompPath) variables
            
        Returns:
            Absolute path to the generated consolidated filelist
            
        Raises:
            FileNotFoundError: If any input filelist doesn't exist
            PermissionError: If lacking permissions to read/write files
            ValueError: If empty filelist is provided
        """
        # Initialize logging
        self.logger.info(f"Starting filelist processing and store the consolidated file in: {workdir}")
        self.logger.debug(f"Input filelist: {filelist}")
        if comppath:
            self.logger.debug(f"Using CompPath replacement: {comppath}")

        # Input validation
        if not filelist:
            self.logger.error("Empty filelist provided - nothing to process")
            raise ValueError("Empty filelist provided - nothing to process")

        if not isinstance(filelist, (list, tuple)):
            self.logger.error("filelist must be a list of file paths")
            raise TypeError("filelist must be a list of file paths")

        # Convert to Path objects for better path handling
        workdir_path = Path(workdir).resolve()
        if febuild:
            output_path = workdir_path / "filelist.f"
        else:
            output_path = workdir_path.parent / "filelist.f"
        self.logger.info(f"Output will be written to: {output_path}")

        abspaths = []
        processed_files = set()  # Track processed files to avoid duplicates

        try:
            for flist in filelist:
                file_dir = os.path.dirname(flist)
                self.logger.debug(f"Processing filelist: {flist}")

                # Verify file exists and is readable
                if not os.path.exists(flist):
                    self.logger.error(f"Filelist not found: {flist}")
                    raise FileNotFoundError(f"Filelist not found: {flist}")
                if not os.access(flist, os.R_OK):
                    self.logger.error(f"Cannot read file: {flist}")
                    raise PermissionError(f"Cannot read file: {flist}")

                with open(flist, 'r') as f:
                    self.logger.debug('all lines are stripped for leading/trailing whitespaces')
                    for line_num, line in enumerate(f, 1):
                        line = line.strip()
                        
                        # Skip comments/empty lines
                        if not line or line.startswith(('#', '//', '--')):
                            self.logger.debug(f"Skipping line {line_num}: {line}")
                            continue
                        
                        processed_line = self._process_line(line=line.replace("$(CompPath)",comppath),base_dir=file_dir,line_num=line_num)+'\n'
                        if processed_line:
                            if processed_line not in processed_files:
                                abspaths.append(processed_line)
                                processed_files.add(processed_line)
                                self.logger.debug(f"Added path: {processed_line}")
                                self.logger.space()
                            else:
                                self.logger.debug(f"Skipping duplicate: {processed_line}")
                                self.logger.space()
                        else:
                            self.logger.debug(f"Skipping unprocessable line {line_num}: {line}")
                            self.logger.space()

            # Write output
            self.logger.info(f"Writing {len(abspaths)} paths to output file")
            try:
                with open(output_path, 'w+') as f:
                    f.write('\n'.join(abspaths))
                    if abspaths:  # Ensure trailing newline if content exists
                        f.write('\n')
                self.logger.info(f"Successfully wrote output to {output_path}")
            except IOError as e:
                self.logger.error(f"Failed to write output file {output_path}: {str(e)}")
                raise IOError(f"Failed to write output file {output_path}: {str(e)}")
                
        except Exception as e:
            self.logger.error(f"Error during processing filelist: {str(e)}", exc_info=True)
            # Clean up partially written file if something went wrong
            if output_path.exists():
                try:
                    self.logger.warning("Cleaning up partially written output file")
                    output_path.unlink()
                except Exception as cleanup_error:
                    self.logger.error(f"Failed to clean up output file: {str(cleanup_error)}")
            raise  # Re-raise the original exception
            
        return str(output_path)
        
    def run(self,opts):
        # obtain tool options from tool_opts file
        self.parse_tool_opts(opts.tool_opts)
        #TODO: support vhdl input files
        #vcom = "vcom " + self.opts_dict.get('vcom', '')
        self._vlog = "vlog " + self.opts_dict.get('vlog', '') if 'vlog' in self.opts_dict else "vlog -sv -64 -svinputport=relaxed -l compile_vl.log"
        self._qverify = "qverify " + self.opts_dict.get('qverify', '')
        self._vopt = "vopt " + self.opts_dict.get('vopt', '')

        # if the febuild option is not specified
        if not opts.febuild: 
            # generate absolute paths for arguments
            self.gen_abspath(opts=opts)
            # turn the filelist into absolute path
            self.logger.underline('Starting Filelist Conversion...')
            opts.filelist = self.gen_filelist_abspaths(filelist=opts.filelist,workdir=opts.workdir,comppath=self._comppath)
        else:
            # generate absolute paths for arguments
            self.gen_abspath(opts=opts)
            if opts.filelist:
                opts.filelist = self.gen_filelist_abspaths(filelist=opts.filelist,workdir=opts.workdir,comppath=opts.comppath,febuild=opts.febuild)
                
        self.logger.header(message='Finished Path -> Absolute Path Section',symbol='=')
        self.logger.line()
        # change directory into the work directory 
        os.chdir(opts.workdir)
        self.logger.info(f"Enter work directory {opts.workdir}")
        # make a directory inside "workdir" called Results
        os.makedirs('Results', exist_ok=True)
        self.logger.info(f"Make Result Directory {opts.workdir}/Results")
        self.logger.line()
        
        # Now start creating script to be submitted to bsub
        self.logger.header(message=f"Generating compile_{opts.subparser_name} Section",symbol='=')
        self.logger.info("Begin writing script in compile_lint.")
        compile_action="#!/usr/bin/csh -f\n"
        
        # add the default prescripts of the specific tool
        compile_action += self._def_prescript(opts) # run any default prescripts
                
        # if the prescript option is specified
        if opts.prescript:
            compile_action += self.line(newline=True)
            compile_action += self.underline(msg="User Specified Prescript",with_backslash=True)
            for prescript in opts.prescript:
                prescript = self._filepath_err_handling(prescript) # handle the fileread and sanitized the filepath
                # Open file with explicit encoding (avoid platform-dependent issues)
                compile_action += f'# Reading {prescript}...\n'
                with open(prescript, 'r', encoding='utf-8') as f:
                    content = f.read()
                # Validate content was read (empty files are allowed, but handle if needed)
                if not prescript.strip():
                    self.logger.warning(f"Prescript file is empty: {opts.prescript}")
                compile_action += content
                compile_action += f'# Closing {prescript}...\n'
            compile_action += self.line(newline=False)

        compile_action += self.line(newline=False)
        compile_action+='vlib ' + opts.lib
        compile_action+='\nvmap work ' + opts.lib + '\n'
        
        if not opts.subparser_name == "lint":
            compile_action+= self._def_vlog(opts)
            
        compile_action += self.line(newline=True)
        
        compile_action += self.close_header(msg='Qverify Section',level=1,with_backslash=False, count_len=False, symbol='=')
        
        compile_action+= f'{self._qverify} -c -od Results -do "\\\n'
        
        # add the default tool methodology 
        compile_action += self._def_methodology(opts)
            
        if opts.pref_file:
            self.logger.underline("Reading User Specified Preference File")
            for pref_file in opts.pref_file:
                self.logger.info(f"Opening {pref_file}")
                pref_file = self._filepath_err_handling(pref_file)
                compile_action += self.underline(msg='User Specified Preference File',with_backslash=True)
                compile_action += f'  do {pref_file};\\\n'
            self.logger.info("Finished reading all user specified preference file.")
            self.logger.space()
            
        if opts.pref:
            self.logger.underline("Reading User Specified Preference File/Commands")
            for pref in opts.pref:
                if os.path.isfile(pref): # check if the value in pref is a file
                    pref = self._filepath_err_handling(pref)
                    compile_action+= f'do {pref};\\\n'
                else:
                    compile_action+= f'{pref};\\\n'
            self.logger.info("Finished reading all user specified preference file/commands.")
            self.logger.space()  
                    
        compile_action += '\\\n'
         
        compile_action += self._def_prerun(opts) # run any default prerun commands
        
        if opts.subparser_name == 'lint':
            compile_action+= self._def_vlog(opts)
            
        run_args = self._def_args(opts)
        compile_action += self.underline(msg='Lint Run Command',symbol='-',with_backslash=True)
        compile_action +=  f'''  {opts.subparser_name} run {self.opts_dict.get(f'{opts.subparser_name} run', '')} -d {opts.top};\\\n'''
        compile_action += '\\\n'

        if opts.dofile:
            compile_action += self.underline(msg='Additional Do File By User: dofile', with_backslash=True)
            for dofile in opts.dofile:
                dofile = self._filepath_err_handling(dofile)
                compile_action+= f' do {dofile};\\\n'
        
        # add default tool postrun commands
        compile_action += self._def_postrun(opts)
        # End of the qverify section 
        compile_action += f'  exit;"\n'
        compile_action += self.close_header(msg="End Qverify Section",level=1,with_backslash=False, count_len=False, symbol='=')
        
        # Put in a common error
        self.logger.debug('If the job return an error of Unmatch " , check the qverify do " ... " and make sure there is no empty line and there is \\ for line continuation.')
        # print out supress messages specified in tool_opts
        if 'suppress' in self.opts_dict:
            self.logger.warning('There is warning supression in this run. Check "suppressed_error" for more information.')
            with open("suppressed_error",'w+')as f:
                # Explain any suppression of error messages
                f.write(f'Suppression Explaination: \n')
                for suppress_msg in self.opts_dict['suppress']:  # Iterate over each message
                    f.write(suppress_msg + '\n')   # Append each message + newline
        
        # Run the default tools' postscript       
        compile_action += self._def_postscript(opts)
        
        # Check of any user specified postscript
        if opts.postscript:
            compile_action += self.underline(msg='User Specified Postscript')
            for postscript in opts.postscript:
                postscript = self._filepath_err_handling(postscript)
                with open (postscript, 'r') as f:
                    content = f.read()
                compile_action += content
            compile_action += '\n'
        compile_action += self.close_header(msg="End Postscript Section",with_backslash=False,level=1, symbol='=')
        
        # Finally, write the script into a file to be submitted to bsub
        with open("compile_"+opts.subparser_name, 'w+') as f:
            f.write(compile_action)
        self.logger.header(message=f"Finished writing compile_{opts.subparser_name}.",symbol='=')
        self.logger.line()
            
        return "compile_"+opts.subparser_name
        
    def gui_mode(self,opts):
        if not opts.febuild:
            opts.workdir = os.path.abspath(opts.workdir + f"/{opts.top}/{opts.subparser_name}/")
        
        if opts.database_file:
            self.logger.debug(f"Processing database file: {opts.database_file}")
            opts.database_file = self.abs_path(
                path=opts.database_file,
                var_name="database_file",
                strict=False,
                check_exists=True
            )
            self.logger.info(f"Database File resolved to: {opts.database_file}")
        else:
            self.logger.debug("No database file specified")
        compile_action="#!/usr/bin/csh -f\n"
            
        if opts.database_file: # If database file is specified, use database file instead of workdir
            try:
                with open(opts.database_file, "r") as file:
                    self.logger.info(f"lint database file: {opts.database_file}")
                    self.logger.info("Database File Exist. Proceed to parse database file to Qverify.")
            except FileNotFoundError as e:
                if e.errno == errno.ENOENT:
                    self.logger.error(f"FileNotFoundError: [Errno {e.errno}] No such file or directory: {opts.database_file}.")
                    self.logger.info(f"Please double check if the path is correctly specified for the db file.")
                    self.logger.info(f"You can either use the /<absolute_path>/<file>.db or <current_dir>/<relative_path>/<file>.db")
                elif e.errno == errno.ENOTDIR:
                    self.logger.error(f"FileNotFoundError: [Errno {e.errno}] Not a directory: {opts.database_file}.")
                    self.logger.info(f"Please double check if the path is correctly specified for the db file.")
                    self.logger.info(f"You can either use the /<absolute_path>/<file>.db or <current_dir>/<relative_path>/<file>.db")
                else:
                    self.logger.error(f"FileNotFoundError: [Errno {e.errno} Unknown FileNotFoundError: {opts.database_file}]")
                    self.logger.info(f"Please double check if the path is correctly specified for the db file.")
                    self.logger.info(f"You can either use the /<absolute_path>/<file>.db or <current_dir>/<relative_path>/<file>.db")
                sys.exit(1)
            except PermissionError as e:
                if e.errno == errno.EACCES:
                    self.logger.error(f"PermissionError: [Errno {e.errno}] No permission to access: '{opts.database_file}'")
                    self.logger.info(f"Please Change the permission access to the file: '{opts.database_file}'")
                elif e.errno == errno.EPERM:
                    self.logger.error(f"PermissionError: [Errno {e.errno}] Operation not permitted: '{opts.database_file}'")
                    self.logger.info(f"PLease double check the operation.")
                else:
                    self.logger.error(f"PermissionError: [Errno {e.errno}] Unknown PermissionError: '{opts.database_file}'")
                    self.logger.info(f"PLease double check the operation.")
                sys.exit(1)
            else:
                #opts.workdir = os.path.dirname(os.path.dirname(opts.database_file))
                command=opts.workdir+'/'+"compile_"+opts.subparser_name+"_gui"
                compile_action+=f'qverify {opts.database_file}\\\n'
                os.chdir(opts.workdir) # change directory one level higher     
        else: # if database file is not specified, use workdir
            try: # check if  <workdir_name>/<top>/<action> exist
                os.listdir(opts.workdir)
            except FileNotFoundError as e:
                if e.errno == errno.ENOENT:
                    self.logger.error(f"FileNotFoundError: [Errno {e.errno}] No such file or directory: The default 'workdir' name doest not exist.")
                    self.logger.info("Please specify the work directory using the -o / --workdir <work_directory> command.")
                elif e.errno == errno.ENOTDIR:
                    self.logger.error(f"FileNotFoundError: [Errno {e.errno}] Not a directory: {opts.database_file}.")
                    self.logger.info("Please specify the work directory instead of a filename using the -o / --workdir <work_directory> command.")
                else:
                    self.logger.error(f"FileNotFoundError: [Errno {e.errno} Unknown FileNotFoundError: {opts.database_file}]")
                    self.logger.info("Please specify the work directory instead of a filename using the -o / --workdir <work_directory> command.")
                sys.exit(1)
            except PermissionError as e:
                if e.errno == errno.EACCES:
                    self.logger.error(f"PermissionError: [Errno {e.errno}] No permission to access directory: '{opts.workdir}'")
                    self.logger.info(f"PLease double check the operation.")
                elif e.errno == errno.EPERM:
                    self.logger.error(f"PermissionError: [Errno {e.errno}] Operation not permitted on: '{opts.workdir}'")
                    self.logger.info(f"PLease double check the operation.")
                else:
                    self.logger.error(f"PermissionError: [Errno {e.errno}] Unknown PermissionError: '{opts.database_file}'")
                    self.logger.info(f"PLease double check the operation.")
                sys.exit(1)
            else:
                command=opts.workdir+'/'+"compile_"+opts.subparser_name+"_gui"
                compile_action+="qverify "+opts.workdir
                compile_action+=f'/Results/{opts.subparser_name}.db \\\n'
                # change directory to workdir directory 
                os.chdir(opts.workdir)

        with open(command,'w+') as f:
            f.write(compile_action)
        
        self.logger.debug(compile_action)
        
        return command
    
    # Protected member methods access by the "run" function. override it in child class
    def _def_prescript(self,opts):
        compile_action = ''
        return compile_action
        
    def _def_prerun(self,opts):
        compile_action = ''
        return compile_action
        
    def _def_methodology(self,opts):
        compile_action = ''
        return compile_action
    
    def _def_args(self,opts):
        args = ''
        return args

    def _def_postrun(self,opts):
        compile_action = ''
        return compile_action
        
    def _def_postscript(self,opts):
        compile_action = ''
        return compile_action
        
    def _def_vlog(self,opts):
        compile_action = ''
        if not opts.febuild:
            if opts.subparser_name == "lint" and opts.compile_cmd:
                compile_action+= f'{self._vlog} -work {opts.lib} -f ' + opts.compile_cmd + ';\n'
            elif opts.filelist:
                compile_action+= f'{self._vlog} -work {opts.lib} -f ' + opts.filelist + ';\n'
            else:
                self.logger.error("no Filelist can be found.")
                sys.exit(1)
        return compile_action
    
    def _get_gui_args(self):
        return {
            'gui': {
                'short': '-g',
                'long': '--gui',
                'help': 'Enable GUI mode',
                'action': 'store_true',
                'default': False
            },            
            'database_file': {
                'short': '-db',
                'long': '--database_file',
                'help': 'Database file for GUI',
                'default': ''
            },
        }
    def _get_shared_args(self):
        """Central configuration for all shared command-line arguments"""
        return {
            'help': {
                'short': '-h',
                'long': '--help',
                'action': 'help',
                'help': 'help',
                'default': None
            },
            'top': {
                'short': '-t',
                'long': '--top',
                'help': 'Define the Top module',
                'default': ""
            },
            'comppath': {
                'short': '-cp',
                'long': '--comppath',
                'help': 'Component path used in .f files generated by febuild',
                'default': ""
            },
            'lib': {
                'short': '-l',
                'long': '--lib',
                'help': 'Library to store Comp/Elab source files',
                'default': "oc_libVlog"
            },
            'workdir': {
                'short': '-o',
                'long': '--workdir',
                'help': 'Workdir output directory',
                'default': self._workdir
            },
            'filelist': {
                'short': '-f',
                'long': '--filelist',
                'help': 'Filelist format supported by questa',
                'action': Extend,
                'nargs': '*',
                'default': []
            },
            'pref_file': {
                'short': '-pf',
                'long': '--pref_file',
                'help': 'Do file (.tcl). Tool Preferences file for pre analysis',
                'action': Extend,
                'nargs': '*',
                'default': []
            },
            'pref': {
                'short': '-p',
                'long': '--pref',
                'help': 'Tool Preferences or custom do file pre analysis',
                'action': Extend,
                'nargs': '*',
                'default': []
            },
            'dofile': {
                'short': '-do',
                'long': '--dofile',
                'help': 'Do file (.tcl). Use to specify post analysis tool directives',
                'action': Extend,
                'nargs': '*',
                'default': []
            },
            'waiver': {
                'short': '-w',
                'long': '--waiver',
                'help': 'Use to add waiver files to tool run',
                'action': Extend,
                'nargs': '*',
                'default': []
            },
            'tool_opts': {
                'short': '-opt',
                'long': '--tool_opts',
                'help': 'Tool options file path',
                'action': Extend,
                'nargs': '*',
                'default': []
            },
            'prescript': {
                'short': '-pre',
                'long': '--prescript',
                'help': 'Custom prescript csh file',
                'action': Extend,
                'nargs': '*',
                'default': []
            },
            'postscript': {
                'short': '-post',
                'long': '--postscript',
                'help': 'Custom postscript csh file',
                'action': Extend,
                'nargs': '*',
                'default': []
            }
        }
    
    def _get_flag_args(self):
        return  {
           'interactive': {
                'short': '-i',
                'long': '--interactive',
                'alt_long': '-I',
                'help': 'Show batch job in the terminal',
                'action': 'store_true',
                'default': False
            },
            'febuild': {
                'short': '-fb',
                'long': '--febuild',
                'help': 'Flag used by febuild',
                'action': 'store_true',
                'default': False
            },
            'skip_exec': {
                'short': '-se',
                'long': '--skip_exec',
                'help': 'Skip the submission to bsub',
                'action': 'store_true',
                'default': False
            },
            'verbose': {
                'short': '-v',
                'long': '--verbose',
                'help': 'Specify True for log file Debugging',
                'action': 'store_true',
                'default': False
            },
            'clean': {
                'short': '-cl',
                'long': '--clean',
                'help': 'Clean work directory',
                'action': 'store_true',
                'default': False
            }
        }


